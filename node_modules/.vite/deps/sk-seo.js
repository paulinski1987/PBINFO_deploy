import "./chunk-TE5TN4QG.js";
import {
  HtmlTagHydration,
  SvelteComponentDev,
  add_location,
  append_hydration_dev,
  attr_dev,
  claim_element,
  claim_html_tag,
  claim_space,
  component_subscribe,
  create_slot,
  detach_dev,
  dispatch_dev,
  element,
  empty,
  get_all_dirty_from_scope,
  get_slot_changes,
  head_selector,
  init,
  insert_hydration_dev,
  noop,
  safe_not_equal,
  space,
  transition_in,
  transition_out,
  update_slot_base,
  validate_slots,
  validate_store
} from "./chunk-SGFLL5OL.js";
import "./chunk-GZA2YTNP.js";
import "./chunk-UV5CTPV7.js";

// node_modules/sk-seo/SEO.svelte
import { page } from "$app/stores";
var file = "node_modules/sk-seo/SEO.svelte";
function create_if_block_14(ctx) {
  let t0;
  let title_value;
  let t1;
  let link;
  let link_content_value;
  function select_block_type(ctx2, dirty) {
    if (
      /*imageURL*/
      ctx2[5]
    )
      return create_if_block_15;
    return create_else_block;
  }
  let current_block_type = select_block_type(ctx, -1);
  let if_block = current_block_type(ctx);
  document.title = title_value = /*title*/
  ctx[0];
  const block = {
    c: function create() {
      if_block.c();
      t0 = space();
      t1 = space();
      link = element("link");
      this.h();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      t0 = claim_space(nodes);
      t1 = claim_space(nodes);
      link = claim_element(nodes, "LINK", { rel: true, content: true });
      this.h();
    },
    h: function hydrate() {
      attr_dev(link, "rel", "canonical");
      attr_dev(link, "content", link_content_value = /*canonical*/
      ctx[3] === "" ? (
        /*$page*/
        ctx[14].url
      ) : (
        /*canonical*/
        ctx[3]
      ));
      add_location(link, file, 36, 8, 1202);
    },
    m: function mount(target, anchor) {
      if_block.m(target, anchor);
      insert_hydration_dev(target, t0, anchor);
      insert_hydration_dev(target, t1, anchor);
      insert_hydration_dev(target, link, anchor);
    },
    p: function update(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type(ctx2, dirty)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(t0.parentNode, t0);
        }
      }
      if (dirty & /*title*/
      1 && title_value !== (title_value = /*title*/
      ctx2[0])) {
        document.title = title_value;
      }
      if (dirty & /*canonical, $page*/
      16392 && link_content_value !== (link_content_value = /*canonical*/
      ctx2[3] === "" ? (
        /*$page*/
        ctx2[14].url
      ) : (
        /*canonical*/
        ctx2[3]
      ))) {
        attr_dev(link, "content", link_content_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t0);
        detach_dev(t1);
        detach_dev(link);
      }
      if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_14.name,
    type: "if",
    source: '(30:4) {#if title !== \\"\\"}',
    ctx
  });
  return block;
}
function create_else_block(ctx) {
  let meta;
  let meta_content_value;
  const block = {
    c: function create() {
      meta = element("meta");
      this.h();
    },
    l: function claim(nodes) {
      meta = claim_element(nodes, "META", { name: true, content: true });
      this.h();
    },
    h: function hydrate() {
      attr_dev(meta, "name", "robots");
      attr_dev(meta, "content", meta_content_value = /*index*/
      ctx[9] ? "index, follow" : "noindex");
      add_location(meta, file, 33, 12, 1082);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, meta, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*index*/
      512 && meta_content_value !== (meta_content_value = /*index*/
      ctx2[9] ? "index, follow" : "noindex")) {
        attr_dev(meta, "content", meta_content_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(meta);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block.name,
    type: "else",
    source: "(33:8) {:else}",
    ctx
  });
  return block;
}
function create_if_block_15(ctx) {
  let meta;
  let meta_content_value;
  const block = {
    c: function create() {
      meta = element("meta");
      this.h();
    },
    l: function claim(nodes) {
      meta = claim_element(nodes, "META", { name: true, content: true });
      this.h();
    },
    h: function hydrate() {
      attr_dev(meta, "name", "robots");
      attr_dev(meta, "content", meta_content_value = /*index*/
      ctx[9] ? "index, follow, max-image-preview:large" : "noindex");
      add_location(meta, file, 31, 12, 962);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, meta, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*index*/
      512 && meta_content_value !== (meta_content_value = /*index*/
      ctx2[9] ? "index, follow, max-image-preview:large" : "noindex")) {
        attr_dev(meta, "content", meta_content_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(meta);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_15.name,
    type: "if",
    source: "(31:8) {#if imageURL}",
    ctx
  });
  return block;
}
function create_if_block_13(ctx) {
  let meta;
  const block = {
    c: function create() {
      meta = element("meta");
      this.h();
    },
    l: function claim(nodes) {
      meta = claim_element(nodes, "META", { name: true, content: true });
      this.h();
    },
    h: function hydrate() {
      attr_dev(meta, "name", "description");
      attr_dev(
        meta,
        "content",
        /*description*/
        ctx[1]
      );
      add_location(meta, file, 39, 8, 1325);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, meta, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*description*/
      2) {
        attr_dev(
          meta,
          "content",
          /*description*/
          ctx2[1]
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(meta);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_13.name,
    type: "if",
    source: '(39:4) {#if description !== \\"\\"}',
    ctx
  });
  return block;
}
function create_if_block_12(ctx) {
  let meta;
  const block = {
    c: function create() {
      meta = element("meta");
      this.h();
    },
    l: function claim(nodes) {
      meta = claim_element(nodes, "META", { name: true, content: true });
      this.h();
    },
    h: function hydrate() {
      attr_dev(meta, "name", "keywords");
      attr_dev(
        meta,
        "content",
        /*keywords*/
        ctx[2]
      );
      add_location(meta, file, 42, 8, 1419);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, meta, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*keywords*/
      4) {
        attr_dev(
          meta,
          "content",
          /*keywords*/
          ctx2[2]
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(meta);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_12.name,
    type: "if",
    source: '(42:4) {#if keywords !== \\"\\"}',
    ctx
  });
  return block;
}
function create_if_block_11(ctx) {
  let meta;
  const block = {
    c: function create() {
      meta = element("meta");
      this.h();
    },
    l: function claim(nodes) {
      meta = claim_element(nodes, "META", { name: true, content: true });
      this.h();
    },
    h: function hydrate() {
      attr_dev(meta, "name", "author");
      attr_dev(
        meta,
        "content",
        /*author*/
        ctx[7]
      );
      add_location(meta, file, 45, 8, 1505);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, meta, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*author*/
      128) {
        attr_dev(
          meta,
          "content",
          /*author*/
          ctx2[7]
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(meta);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_11.name,
    type: "if",
    source: '(45:4) {#if author !== \\"\\"}',
    ctx
  });
  return block;
}
function create_if_block_5(ctx) {
  let t0;
  let t1;
  let t2;
  let t3;
  let if_block4_anchor;
  let if_block0 = (
    /*siteName*/
    ctx[4] !== "" && create_if_block_10(ctx)
  );
  let if_block1 = (
    /*title*/
    ctx[0] !== "" && create_if_block_9(ctx)
  );
  let if_block2 = (
    /*description*/
    ctx[1] !== "" && create_if_block_8(ctx)
  );
  let if_block3 = (
    /*imageURL*/
    ctx[5] !== "" && create_if_block_7(ctx)
  );
  let if_block4 = (
    /*logo*/
    ctx[6] !== "" && create_if_block_6(ctx)
  );
  const block = {
    c: function create() {
      if (if_block0)
        if_block0.c();
      t0 = space();
      if (if_block1)
        if_block1.c();
      t1 = space();
      if (if_block2)
        if_block2.c();
      t2 = space();
      if (if_block3)
        if_block3.c();
      t3 = space();
      if (if_block4)
        if_block4.c();
      if_block4_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block0)
        if_block0.l(nodes);
      t0 = claim_space(nodes);
      if (if_block1)
        if_block1.l(nodes);
      t1 = claim_space(nodes);
      if (if_block2)
        if_block2.l(nodes);
      t2 = claim_space(nodes);
      if (if_block3)
        if_block3.l(nodes);
      t3 = claim_space(nodes);
      if (if_block4)
        if_block4.l(nodes);
      if_block4_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block0)
        if_block0.m(target, anchor);
      insert_hydration_dev(target, t0, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert_hydration_dev(target, t1, anchor);
      if (if_block2)
        if_block2.m(target, anchor);
      insert_hydration_dev(target, t2, anchor);
      if (if_block3)
        if_block3.m(target, anchor);
      insert_hydration_dev(target, t3, anchor);
      if (if_block4)
        if_block4.m(target, anchor);
      insert_hydration_dev(target, if_block4_anchor, anchor);
    },
    p: function update(ctx2, dirty) {
      if (
        /*siteName*/
        ctx2[4] !== ""
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_10(ctx2);
          if_block0.c();
          if_block0.m(t0.parentNode, t0);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (
        /*title*/
        ctx2[0] !== ""
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_9(ctx2);
          if_block1.c();
          if_block1.m(t1.parentNode, t1);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (
        /*description*/
        ctx2[1] !== ""
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
        } else {
          if_block2 = create_if_block_8(ctx2);
          if_block2.c();
          if_block2.m(t2.parentNode, t2);
        }
      } else if (if_block2) {
        if_block2.d(1);
        if_block2 = null;
      }
      if (
        /*imageURL*/
        ctx2[5] !== ""
      ) {
        if (if_block3) {
          if_block3.p(ctx2, dirty);
        } else {
          if_block3 = create_if_block_7(ctx2);
          if_block3.c();
          if_block3.m(t3.parentNode, t3);
        }
      } else if (if_block3) {
        if_block3.d(1);
        if_block3 = null;
      }
      if (
        /*logo*/
        ctx2[6] !== ""
      ) {
        if (if_block4) {
          if_block4.p(ctx2, dirty);
        } else {
          if_block4 = create_if_block_6(ctx2);
          if_block4.c();
          if_block4.m(if_block4_anchor.parentNode, if_block4_anchor);
        }
      } else if (if_block4) {
        if_block4.d(1);
        if_block4 = null;
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t0);
        detach_dev(t1);
        detach_dev(t2);
        detach_dev(t3);
        detach_dev(if_block4_anchor);
      }
      if (if_block0)
        if_block0.d(detaching);
      if (if_block1)
        if_block1.d(detaching);
      if (if_block2)
        if_block2.d(detaching);
      if (if_block3)
        if_block3.d(detaching);
      if (if_block4)
        if_block4.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_5.name,
    type: "if",
    source: "(48:4) {#if openGraph}",
    ctx
  });
  return block;
}
function create_if_block_10(ctx) {
  let meta;
  const block = {
    c: function create() {
      meta = element("meta");
      this.h();
    },
    l: function claim(nodes) {
      meta = claim_element(nodes, "META", { property: true, content: true });
      this.h();
    },
    h: function hydrate() {
      attr_dev(meta, "property", "og:site_name");
      attr_dev(
        meta,
        "content",
        /*siteName*/
        ctx[4]
      );
      add_location(meta, file, 49, 12, 1617);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, meta, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*siteName*/
      16) {
        attr_dev(
          meta,
          "content",
          /*siteName*/
          ctx2[4]
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(meta);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_10.name,
    type: "if",
    source: '(49:8) {#if siteName !== \\"\\"}',
    ctx
  });
  return block;
}
function create_if_block_9(ctx) {
  let meta0;
  let meta0_content_value;
  let t0;
  let meta1;
  let t1;
  let meta2;
  const block = {
    c: function create() {
      meta0 = element("meta");
      t0 = space();
      meta1 = element("meta");
      t1 = space();
      meta2 = element("meta");
      this.h();
    },
    l: function claim(nodes) {
      meta0 = claim_element(nodes, "META", { property: true, content: true });
      t0 = claim_space(nodes);
      meta1 = claim_element(nodes, "META", { property: true, content: true });
      t1 = claim_space(nodes);
      meta2 = claim_element(nodes, "META", { property: true, content: true });
      this.h();
    },
    h: function hydrate() {
      attr_dev(meta0, "property", "og:url");
      attr_dev(meta0, "content", meta0_content_value = /*$page*/
      ctx[14].url);
      add_location(meta0, file, 52, 12, 1722);
      attr_dev(meta1, "property", "og:type");
      attr_dev(meta1, "content", "website");
      add_location(meta1, file, 53, 12, 1781);
      attr_dev(meta2, "property", "og:title");
      attr_dev(
        meta2,
        "content",
        /*title*/
        ctx[0]
      );
      add_location(meta2, file, 54, 12, 1837);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, meta0, anchor);
      insert_hydration_dev(target, t0, anchor);
      insert_hydration_dev(target, meta1, anchor);
      insert_hydration_dev(target, t1, anchor);
      insert_hydration_dev(target, meta2, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*$page*/
      16384 && meta0_content_value !== (meta0_content_value = /*$page*/
      ctx2[14].url)) {
        attr_dev(meta0, "content", meta0_content_value);
      }
      if (dirty & /*title*/
      1) {
        attr_dev(
          meta2,
          "content",
          /*title*/
          ctx2[0]
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(meta0);
        detach_dev(t0);
        detach_dev(meta1);
        detach_dev(t1);
        detach_dev(meta2);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_9.name,
    type: "if",
    source: '(52:8) {#if title !== \\"\\"}',
    ctx
  });
  return block;
}
function create_if_block_8(ctx) {
  let meta;
  const block = {
    c: function create() {
      meta = element("meta");
      this.h();
    },
    l: function claim(nodes) {
      meta = claim_element(nodes, "META", { property: true, content: true });
      this.h();
    },
    h: function hydrate() {
      attr_dev(meta, "property", "og:description");
      attr_dev(
        meta,
        "content",
        /*description*/
        ctx[1]
      );
      add_location(meta, file, 57, 12, 1941);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, meta, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*description*/
      2) {
        attr_dev(
          meta,
          "content",
          /*description*/
          ctx2[1]
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(meta);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_8.name,
    type: "if",
    source: '(57:8) {#if description !== \\"\\"}',
    ctx
  });
  return block;
}
function create_if_block_7(ctx) {
  let meta;
  const block = {
    c: function create() {
      meta = element("meta");
      this.h();
    },
    l: function claim(nodes) {
      meta = claim_element(nodes, "META", { property: true, content: true });
      this.h();
    },
    h: function hydrate() {
      attr_dev(meta, "property", "og:image");
      attr_dev(
        meta,
        "content",
        /*imageURL*/
        ctx[5]
      );
      add_location(meta, file, 60, 12, 2054);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, meta, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*imageURL*/
      32) {
        attr_dev(
          meta,
          "content",
          /*imageURL*/
          ctx2[5]
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(meta);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_7.name,
    type: "if",
    source: '(60:8) {#if imageURL !== \\"\\"}',
    ctx
  });
  return block;
}
function create_if_block_6(ctx) {
  let meta;
  const block = {
    c: function create() {
      meta = element("meta");
      this.h();
    },
    l: function claim(nodes) {
      meta = claim_element(nodes, "META", { property: true, content: true });
      this.h();
    },
    h: function hydrate() {
      attr_dev(meta, "property", "og:logo");
      attr_dev(
        meta,
        "content",
        /*logo*/
        ctx[6]
      );
      add_location(meta, file, 63, 12, 2154);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, meta, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*logo*/
      64) {
        attr_dev(
          meta,
          "content",
          /*logo*/
          ctx2[6]
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(meta);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_6.name,
    type: "if",
    source: '(63:8) {#if logo !== \\"\\"}',
    ctx
  });
  return block;
}
function create_if_block_1(ctx) {
  let t0;
  let t1;
  let if_block2_anchor;
  let if_block0 = (
    /*title*/
    ctx[0] !== "" && create_if_block_4(ctx)
  );
  let if_block1 = (
    /*description*/
    ctx[1] !== "" && create_if_block_3(ctx)
  );
  let if_block2 = (
    /*imageURL*/
    ctx[5] !== "" && create_if_block_2(ctx)
  );
  const block = {
    c: function create() {
      if (if_block0)
        if_block0.c();
      t0 = space();
      if (if_block1)
        if_block1.c();
      t1 = space();
      if (if_block2)
        if_block2.c();
      if_block2_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block0)
        if_block0.l(nodes);
      t0 = claim_space(nodes);
      if (if_block1)
        if_block1.l(nodes);
      t1 = claim_space(nodes);
      if (if_block2)
        if_block2.l(nodes);
      if_block2_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block0)
        if_block0.m(target, anchor);
      insert_hydration_dev(target, t0, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert_hydration_dev(target, t1, anchor);
      if (if_block2)
        if_block2.m(target, anchor);
      insert_hydration_dev(target, if_block2_anchor, anchor);
    },
    p: function update(ctx2, dirty) {
      if (
        /*title*/
        ctx2[0] !== ""
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_4(ctx2);
          if_block0.c();
          if_block0.m(t0.parentNode, t0);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (
        /*description*/
        ctx2[1] !== ""
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_3(ctx2);
          if_block1.c();
          if_block1.m(t1.parentNode, t1);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (
        /*imageURL*/
        ctx2[5] !== ""
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
        } else {
          if_block2 = create_if_block_2(ctx2);
          if_block2.c();
          if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
        }
      } else if (if_block2) {
        if_block2.d(1);
        if_block2 = null;
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t0);
        detach_dev(t1);
        detach_dev(if_block2_anchor);
      }
      if (if_block0)
        if_block0.d(detaching);
      if (if_block1)
        if_block1.d(detaching);
      if (if_block2)
        if_block2.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_1.name,
    type: "if",
    source: "(67:4) {#if twitter}",
    ctx
  });
  return block;
}
function create_if_block_4(ctx) {
  let meta0;
  let t0;
  let meta1;
  let meta1_content_value;
  let t1;
  let meta2;
  let meta2_content_value;
  let t2;
  let meta3;
  const block = {
    c: function create() {
      meta0 = element("meta");
      t0 = space();
      meta1 = element("meta");
      t1 = space();
      meta2 = element("meta");
      t2 = space();
      meta3 = element("meta");
      this.h();
    },
    l: function claim(nodes) {
      meta0 = claim_element(nodes, "META", { name: true, content: true });
      t0 = claim_space(nodes);
      meta1 = claim_element(nodes, "META", { property: true, content: true });
      t1 = claim_space(nodes);
      meta2 = claim_element(nodes, "META", { property: true, content: true });
      t2 = claim_space(nodes);
      meta3 = claim_element(nodes, "META", { name: true, content: true });
      this.h();
    },
    h: function hydrate() {
      attr_dev(meta0, "name", "twitter:card");
      attr_dev(meta0, "content", "summary_large_image");
      add_location(meta0, file, 68, 12, 2278);
      attr_dev(meta1, "property", "twitter:domain");
      attr_dev(meta1, "content", meta1_content_value = /*$page*/
      ctx[14].url.host);
      add_location(meta1, file, 69, 12, 2347);
      attr_dev(meta2, "property", "twitter:url");
      attr_dev(meta2, "content", meta2_content_value = /*$page*/
      ctx[14].url);
      add_location(meta2, file, 70, 12, 2419);
      attr_dev(meta3, "name", "twitter:title");
      attr_dev(
        meta3,
        "content",
        /*title*/
        ctx[0]
      );
      add_location(meta3, file, 71, 12, 2483);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, meta0, anchor);
      insert_hydration_dev(target, t0, anchor);
      insert_hydration_dev(target, meta1, anchor);
      insert_hydration_dev(target, t1, anchor);
      insert_hydration_dev(target, meta2, anchor);
      insert_hydration_dev(target, t2, anchor);
      insert_hydration_dev(target, meta3, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*$page*/
      16384 && meta1_content_value !== (meta1_content_value = /*$page*/
      ctx2[14].url.host)) {
        attr_dev(meta1, "content", meta1_content_value);
      }
      if (dirty & /*$page*/
      16384 && meta2_content_value !== (meta2_content_value = /*$page*/
      ctx2[14].url)) {
        attr_dev(meta2, "content", meta2_content_value);
      }
      if (dirty & /*title*/
      1) {
        attr_dev(
          meta3,
          "content",
          /*title*/
          ctx2[0]
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(meta0);
        detach_dev(t0);
        detach_dev(meta1);
        detach_dev(t1);
        detach_dev(meta2);
        detach_dev(t2);
        detach_dev(meta3);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_4.name,
    type: "if",
    source: '(68:8) {#if title !== \\"\\"}',
    ctx
  });
  return block;
}
function create_if_block_3(ctx) {
  let meta;
  const block = {
    c: function create() {
      meta = element("meta");
      this.h();
    },
    l: function claim(nodes) {
      meta = claim_element(nodes, "META", { name: true, content: true });
      this.h();
    },
    h: function hydrate() {
      attr_dev(meta, "name", "twitter:description");
      attr_dev(
        meta,
        "content",
        /*description*/
        ctx[1]
      );
      add_location(meta, file, 74, 12, 2588);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, meta, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*description*/
      2) {
        attr_dev(
          meta,
          "content",
          /*description*/
          ctx2[1]
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(meta);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_3.name,
    type: "if",
    source: '(74:8) {#if description !== \\"\\"}',
    ctx
  });
  return block;
}
function create_if_block_2(ctx) {
  let meta;
  const block = {
    c: function create() {
      meta = element("meta");
      this.h();
    },
    l: function claim(nodes) {
      meta = claim_element(nodes, "META", { name: true, content: true });
      this.h();
    },
    h: function hydrate() {
      attr_dev(meta, "name", "twitter:image");
      attr_dev(
        meta,
        "content",
        /*imageURL*/
        ctx[5]
      );
      add_location(meta, file, 77, 12, 2702);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, meta, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*imageURL*/
      32) {
        attr_dev(
          meta,
          "content",
          /*imageURL*/
          ctx2[5]
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(meta);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_2.name,
    type: "if",
    source: '(77:8) {#if imageURL !== \\"\\"}',
    ctx
  });
  return block;
}
function create_if_block(ctx) {
  let html_tag;
  let html_anchor;
  const block = {
    c: function create() {
      html_tag = new HtmlTagHydration(false);
      html_anchor = empty();
      this.h();
    },
    l: function claim(nodes) {
      html_tag = claim_html_tag(nodes, false);
      html_anchor = empty();
      this.h();
    },
    h: function hydrate() {
      html_tag.a = html_anchor;
    },
    m: function mount(target, anchor) {
      html_tag.m(
        /*LdScript*/
        ctx[15],
        target,
        anchor
      );
      insert_hydration_dev(target, html_anchor, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(html_anchor);
        html_tag.d();
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block.name,
    type: "if",
    source: '(82:4) {#if schemaOrg || socials[0] !== undefined || logo !== \\"\\" || name !== \\"\\"}',
    ctx
  });
  return block;
}
function create_fragment(ctx) {
  let if_block0_anchor;
  let if_block1_anchor;
  let if_block2_anchor;
  let if_block3_anchor;
  let if_block4_anchor;
  let if_block5_anchor;
  let if_block6_anchor;
  let current;
  let if_block0 = (
    /*title*/
    ctx[0] !== "" && create_if_block_14(ctx)
  );
  let if_block1 = (
    /*description*/
    ctx[1] !== "" && create_if_block_13(ctx)
  );
  let if_block2 = (
    /*keywords*/
    ctx[2] !== "" && create_if_block_12(ctx)
  );
  let if_block3 = (
    /*author*/
    ctx[7] !== "" && create_if_block_11(ctx)
  );
  let if_block4 = (
    /*openGraph*/
    ctx[11] && create_if_block_5(ctx)
  );
  let if_block5 = (
    /*twitter*/
    ctx[10] && create_if_block_1(ctx)
  );
  const default_slot_template = (
    /*#slots*/
    ctx[18].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[17],
    null
  );
  let if_block6 = (
    /*schemaOrg*/
    (ctx[12] || /*socials*/
    ctx[13][0] !== void 0 || /*logo*/
    ctx[6] !== "" || /*name*/
    ctx[8] !== "") && create_if_block(ctx)
  );
  const block = {
    c: function create() {
      if (if_block0)
        if_block0.c();
      if_block0_anchor = empty();
      if (if_block1)
        if_block1.c();
      if_block1_anchor = empty();
      if (if_block2)
        if_block2.c();
      if_block2_anchor = empty();
      if (if_block3)
        if_block3.c();
      if_block3_anchor = empty();
      if (if_block4)
        if_block4.c();
      if_block4_anchor = empty();
      if (if_block5)
        if_block5.c();
      if_block5_anchor = empty();
      if (default_slot)
        default_slot.c();
      if (if_block6)
        if_block6.c();
      if_block6_anchor = empty();
    },
    l: function claim(nodes) {
      const head_nodes = head_selector("svelte-1jjodqw", document.head);
      if (if_block0)
        if_block0.l(head_nodes);
      if_block0_anchor = empty();
      if (if_block1)
        if_block1.l(head_nodes);
      if_block1_anchor = empty();
      if (if_block2)
        if_block2.l(head_nodes);
      if_block2_anchor = empty();
      if (if_block3)
        if_block3.l(head_nodes);
      if_block3_anchor = empty();
      if (if_block4)
        if_block4.l(head_nodes);
      if_block4_anchor = empty();
      if (if_block5)
        if_block5.l(head_nodes);
      if_block5_anchor = empty();
      if (default_slot)
        default_slot.l(head_nodes);
      if (if_block6)
        if_block6.l(head_nodes);
      if_block6_anchor = empty();
      head_nodes.forEach(detach_dev);
    },
    m: function mount(target, anchor) {
      if (if_block0)
        if_block0.m(document.head, null);
      append_hydration_dev(document.head, if_block0_anchor);
      if (if_block1)
        if_block1.m(document.head, null);
      append_hydration_dev(document.head, if_block1_anchor);
      if (if_block2)
        if_block2.m(document.head, null);
      append_hydration_dev(document.head, if_block2_anchor);
      if (if_block3)
        if_block3.m(document.head, null);
      append_hydration_dev(document.head, if_block3_anchor);
      if (if_block4)
        if_block4.m(document.head, null);
      append_hydration_dev(document.head, if_block4_anchor);
      if (if_block5)
        if_block5.m(document.head, null);
      append_hydration_dev(document.head, if_block5_anchor);
      if (default_slot) {
        default_slot.m(document.head, null);
      }
      if (if_block6)
        if_block6.m(document.head, null);
      append_hydration_dev(document.head, if_block6_anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*title*/
        ctx2[0] !== ""
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_14(ctx2);
          if_block0.c();
          if_block0.m(if_block0_anchor.parentNode, if_block0_anchor);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (
        /*description*/
        ctx2[1] !== ""
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_13(ctx2);
          if_block1.c();
          if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (
        /*keywords*/
        ctx2[2] !== ""
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
        } else {
          if_block2 = create_if_block_12(ctx2);
          if_block2.c();
          if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
        }
      } else if (if_block2) {
        if_block2.d(1);
        if_block2 = null;
      }
      if (
        /*author*/
        ctx2[7] !== ""
      ) {
        if (if_block3) {
          if_block3.p(ctx2, dirty);
        } else {
          if_block3 = create_if_block_11(ctx2);
          if_block3.c();
          if_block3.m(if_block3_anchor.parentNode, if_block3_anchor);
        }
      } else if (if_block3) {
        if_block3.d(1);
        if_block3 = null;
      }
      if (
        /*openGraph*/
        ctx2[11]
      ) {
        if (if_block4) {
          if_block4.p(ctx2, dirty);
        } else {
          if_block4 = create_if_block_5(ctx2);
          if_block4.c();
          if_block4.m(if_block4_anchor.parentNode, if_block4_anchor);
        }
      } else if (if_block4) {
        if_block4.d(1);
        if_block4 = null;
      }
      if (
        /*twitter*/
        ctx2[10]
      ) {
        if (if_block5) {
          if_block5.p(ctx2, dirty);
        } else {
          if_block5 = create_if_block_1(ctx2);
          if_block5.c();
          if_block5.m(if_block5_anchor.parentNode, if_block5_anchor);
        }
      } else if (if_block5) {
        if_block5.d(1);
        if_block5 = null;
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        131072)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[17],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[17]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[17],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (
        /*schemaOrg*/
        ctx2[12] || /*socials*/
        ctx2[13][0] !== void 0 || /*logo*/
        ctx2[6] !== "" || /*name*/
        ctx2[8] !== ""
      ) {
        if (if_block6) {
          if_block6.p(ctx2, dirty);
        } else {
          if_block6 = create_if_block(ctx2);
          if_block6.c();
          if_block6.m(if_block6_anchor.parentNode, if_block6_anchor);
        }
      } else if (if_block6) {
        if_block6.d(1);
        if_block6 = null;
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block0)
        if_block0.d(detaching);
      detach_dev(if_block0_anchor);
      if (if_block1)
        if_block1.d(detaching);
      detach_dev(if_block1_anchor);
      if (if_block2)
        if_block2.d(detaching);
      detach_dev(if_block2_anchor);
      if (if_block3)
        if_block3.d(detaching);
      detach_dev(if_block3_anchor);
      if (if_block4)
        if_block4.d(detaching);
      detach_dev(if_block4_anchor);
      if (if_block5)
        if_block5.d(detaching);
      detach_dev(if_block5_anchor);
      if (default_slot)
        default_slot.d(detaching);
      if (if_block6)
        if_block6.d(detaching);
      detach_dev(if_block6_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance($$self, $$props, $$invalidate) {
  let $page;
  validate_store(page, "page");
  component_subscribe($$self, page, ($$value) => $$invalidate(14, $page = $$value));
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("SEO", slots, ["default"]);
  let { title = "", description = "", keywords = "", canonical = "", siteName = "", imageURL = "", logo = "", author = "", name = "" } = $$props;
  let { index = true, twitter = true, openGraph = true } = $$props;
  let { schemaOrg = false } = $$props;
  let { socials = [], jsonld = {} } = $$props;
  let Ld = {
    "@context": "https://schema.org",
    "@type": ["Person", "Organization"],
    "name": `${name}`,
    "url": `${$page.url.origin}`,
    "image": `${imageURL}`,
    "logo": {
      "@type": "ImageObject",
      "url": `${logo}`,
      "width": 48,
      "height": 48
    },
    "sameAs": [`${socials.join(", ")}`]
  };
  Ld = { ...Ld, ...jsonld };
  let LdScript = `<script type="application/ld+json">${JSON.stringify(Ld)}${"<"}/script>`;
  const writable_props = [
    "title",
    "description",
    "keywords",
    "canonical",
    "siteName",
    "imageURL",
    "logo",
    "author",
    "name",
    "index",
    "twitter",
    "openGraph",
    "schemaOrg",
    "socials",
    "jsonld"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<SEO> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("title" in $$props2)
      $$invalidate(0, title = $$props2.title);
    if ("description" in $$props2)
      $$invalidate(1, description = $$props2.description);
    if ("keywords" in $$props2)
      $$invalidate(2, keywords = $$props2.keywords);
    if ("canonical" in $$props2)
      $$invalidate(3, canonical = $$props2.canonical);
    if ("siteName" in $$props2)
      $$invalidate(4, siteName = $$props2.siteName);
    if ("imageURL" in $$props2)
      $$invalidate(5, imageURL = $$props2.imageURL);
    if ("logo" in $$props2)
      $$invalidate(6, logo = $$props2.logo);
    if ("author" in $$props2)
      $$invalidate(7, author = $$props2.author);
    if ("name" in $$props2)
      $$invalidate(8, name = $$props2.name);
    if ("index" in $$props2)
      $$invalidate(9, index = $$props2.index);
    if ("twitter" in $$props2)
      $$invalidate(10, twitter = $$props2.twitter);
    if ("openGraph" in $$props2)
      $$invalidate(11, openGraph = $$props2.openGraph);
    if ("schemaOrg" in $$props2)
      $$invalidate(12, schemaOrg = $$props2.schemaOrg);
    if ("socials" in $$props2)
      $$invalidate(13, socials = $$props2.socials);
    if ("jsonld" in $$props2)
      $$invalidate(16, jsonld = $$props2.jsonld);
    if ("$$scope" in $$props2)
      $$invalidate(17, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    page,
    title,
    description,
    keywords,
    canonical,
    siteName,
    imageURL,
    logo,
    author,
    name,
    index,
    twitter,
    openGraph,
    schemaOrg,
    socials,
    jsonld,
    Ld,
    LdScript,
    $page
  });
  $$self.$inject_state = ($$props2) => {
    if ("title" in $$props2)
      $$invalidate(0, title = $$props2.title);
    if ("description" in $$props2)
      $$invalidate(1, description = $$props2.description);
    if ("keywords" in $$props2)
      $$invalidate(2, keywords = $$props2.keywords);
    if ("canonical" in $$props2)
      $$invalidate(3, canonical = $$props2.canonical);
    if ("siteName" in $$props2)
      $$invalidate(4, siteName = $$props2.siteName);
    if ("imageURL" in $$props2)
      $$invalidate(5, imageURL = $$props2.imageURL);
    if ("logo" in $$props2)
      $$invalidate(6, logo = $$props2.logo);
    if ("author" in $$props2)
      $$invalidate(7, author = $$props2.author);
    if ("name" in $$props2)
      $$invalidate(8, name = $$props2.name);
    if ("index" in $$props2)
      $$invalidate(9, index = $$props2.index);
    if ("twitter" in $$props2)
      $$invalidate(10, twitter = $$props2.twitter);
    if ("openGraph" in $$props2)
      $$invalidate(11, openGraph = $$props2.openGraph);
    if ("schemaOrg" in $$props2)
      $$invalidate(12, schemaOrg = $$props2.schemaOrg);
    if ("socials" in $$props2)
      $$invalidate(13, socials = $$props2.socials);
    if ("jsonld" in $$props2)
      $$invalidate(16, jsonld = $$props2.jsonld);
    if ("Ld" in $$props2)
      Ld = $$props2.Ld;
    if ("LdScript" in $$props2)
      $$invalidate(15, LdScript = $$props2.LdScript);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    title,
    description,
    keywords,
    canonical,
    siteName,
    imageURL,
    logo,
    author,
    name,
    index,
    twitter,
    openGraph,
    schemaOrg,
    socials,
    $page,
    LdScript,
    jsonld,
    $$scope,
    slots
  ];
}
var SEO = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance, create_fragment, safe_not_equal, {
      title: 0,
      description: 1,
      keywords: 2,
      canonical: 3,
      siteName: 4,
      imageURL: 5,
      logo: 6,
      author: 7,
      name: 8,
      index: 9,
      twitter: 10,
      openGraph: 11,
      schemaOrg: 12,
      socials: 13,
      jsonld: 16
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "SEO",
      options,
      id: create_fragment.name
    });
  }
  get title() {
    throw new Error("<SEO>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<SEO>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get description() {
    throw new Error("<SEO>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set description(value) {
    throw new Error("<SEO>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get keywords() {
    throw new Error("<SEO>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set keywords(value) {
    throw new Error("<SEO>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get canonical() {
    throw new Error("<SEO>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set canonical(value) {
    throw new Error("<SEO>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get siteName() {
    throw new Error("<SEO>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set siteName(value) {
    throw new Error("<SEO>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get imageURL() {
    throw new Error("<SEO>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set imageURL(value) {
    throw new Error("<SEO>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get logo() {
    throw new Error("<SEO>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set logo(value) {
    throw new Error("<SEO>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get author() {
    throw new Error("<SEO>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set author(value) {
    throw new Error("<SEO>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get name() {
    throw new Error("<SEO>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set name(value) {
    throw new Error("<SEO>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get index() {
    throw new Error("<SEO>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set index(value) {
    throw new Error("<SEO>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get twitter() {
    throw new Error("<SEO>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set twitter(value) {
    throw new Error("<SEO>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get openGraph() {
    throw new Error("<SEO>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set openGraph(value) {
    throw new Error("<SEO>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get schemaOrg() {
    throw new Error("<SEO>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set schemaOrg(value) {
    throw new Error("<SEO>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get socials() {
    throw new Error("<SEO>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set socials(value) {
    throw new Error("<SEO>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get jsonld() {
    throw new Error("<SEO>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set jsonld(value) {
    throw new Error("<SEO>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var SEO_default = SEO;
export {
  SEO_default as default
};
//# sourceMappingURL=sk-seo.js.map
